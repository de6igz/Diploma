// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"context"
	"strconv"

	"github.com/gofiber/fiber/v2"
)

func (http *httpRules) getRules(ctx context.Context, request requestRulesGetRules) (response responseRulesGetRules, err error) {

	response.Items, err = http.svc.GetRules(ctx, request.UserId)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
	}
	return
}
func (http *httpRules) serveGetRules(ctx *fiber.Ctx) (err error) {

	var request requestRulesGetRules

	if _userId := string(ctx.Request().Header.Peek("X-User-Id")); _userId != "" {
		var userId int64
		userId, err = strconv.ParseInt(_userId, 10, 64)
		if err != nil {
			ctx.Status(fiber.StatusBadRequest)
			return sendResponse(ctx, "http header could not be decoded: "+err.Error())
		}
		request.UserId = userId
	}

	var response responseRulesGetRules
	if response, err = http.getRules(ctx.UserContext(), request); err == nil {
		var iResponse interface{} = response
		if redirect, ok := iResponse.(withRedirect); ok {
			return ctx.Redirect(redirect.RedirectTo())
		}

		return sendResponse(ctx, response)
	}
	if errCoder, ok := err.(withErrorCode); ok {
		ctx.Status(errCoder.Code())
	} else {
		ctx.Status(fiber.StatusInternalServerError)
	}
	return sendResponse(ctx, err)
}
func (http *httpRules) getRuleByID(ctx context.Context, request requestRulesGetRuleByID) (response responseRulesGetRuleByID, err error) {

	response.Rule, err = http.svc.GetRuleByID(ctx, request.UserId, request.RuleId, request.RuleType)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
	}
	return
}
func (http *httpRules) serveGetRuleByID(ctx *fiber.Ctx) (err error) {

	var request requestRulesGetRuleByID

	if _ruleId := ctx.Query("ruleId"); _ruleId != "" {
		var ruleId string
		ruleId = _ruleId
		request.RuleId = ruleId
	}
	if _ruleType := ctx.Query("ruleType"); _ruleType != "" {
		var ruleType string
		ruleType = _ruleType
		request.RuleType = ruleType
	}

	if _userId := string(ctx.Request().Header.Peek("X-User-Id")); _userId != "" {
		var userId int64
		userId, err = strconv.ParseInt(_userId, 10, 64)
		if err != nil {
			ctx.Status(fiber.StatusBadRequest)
			return sendResponse(ctx, "http header could not be decoded: "+err.Error())
		}
		request.UserId = userId
	}

	var response responseRulesGetRuleByID
	if response, err = http.getRuleByID(ctx.UserContext(), request); err == nil {
		var iResponse interface{} = response
		if redirect, ok := iResponse.(withRedirect); ok {
			return ctx.Redirect(redirect.RedirectTo())
		}

		return sendResponse(ctx, response)
	}
	if errCoder, ok := err.(withErrorCode); ok {
		ctx.Status(errCoder.Code())
	} else {
		ctx.Status(fiber.StatusInternalServerError)
	}
	return sendResponse(ctx, err)
}
func (http *httpRules) getAvailableRules(ctx context.Context, request requestRulesGetAvailableRules) (response responseRulesGetAvailableRules, err error) {

	response.Items, err = http.svc.GetAvailableRules(ctx, request.UserId)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
	}
	return
}
func (http *httpRules) serveGetAvailableRules(ctx *fiber.Ctx) (err error) {

	var request requestRulesGetAvailableRules

	if _userId := string(ctx.Request().Header.Peek("X-User-Id")); _userId != "" {
		var userId int64
		userId, err = strconv.ParseInt(_userId, 10, 64)
		if err != nil {
			ctx.Status(fiber.StatusBadRequest)
			return sendResponse(ctx, "http header could not be decoded: "+err.Error())
		}
		request.UserId = userId
	}

	var response responseRulesGetAvailableRules
	if response, err = http.getAvailableRules(ctx.UserContext(), request); err == nil {
		var iResponse interface{} = response
		if redirect, ok := iResponse.(withRedirect); ok {
			return ctx.Redirect(redirect.RedirectTo())
		}

		return sendResponse(ctx, response)
	}
	if errCoder, ok := err.(withErrorCode); ok {
		ctx.Status(errCoder.Code())
	} else {
		ctx.Status(fiber.StatusInternalServerError)
	}
	return sendResponse(ctx, err)
}
func (http *httpRules) deleteRuleByID(ctx context.Context, request requestRulesDeleteRuleByID) (response responseRulesDeleteRuleByID, err error) {

	response.Status, err = http.svc.DeleteRuleByID(ctx, request.UserId, request.Req)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
	}
	return
}
func (http *httpRules) serveDeleteRuleByID(ctx *fiber.Ctx) (err error) {

	var request requestRulesDeleteRuleByID
	if err = ctx.BodyParser(&request); err != nil {
		ctx.Response().SetStatusCode(fiber.StatusBadRequest)
		_, err = ctx.WriteString("request body could not be decoded: " + err.Error())
		return
	}

	if _userId := string(ctx.Request().Header.Peek("X-User-Id")); _userId != "" {
		var userId int64
		userId, err = strconv.ParseInt(_userId, 10, 64)
		if err != nil {
			ctx.Status(fiber.StatusBadRequest)
			return sendResponse(ctx, "http header could not be decoded: "+err.Error())
		}
		request.UserId = userId
	}

	var response responseRulesDeleteRuleByID
	if response, err = http.deleteRuleByID(ctx.UserContext(), request); err == nil {
		var iResponse interface{} = response
		if redirect, ok := iResponse.(withRedirect); ok {
			return ctx.Redirect(redirect.RedirectTo())
		}

		return sendResponse(ctx, response)
	}
	if errCoder, ok := err.(withErrorCode); ok {
		ctx.Status(errCoder.Code())
	} else {
		ctx.Status(fiber.StatusInternalServerError)
	}
	return sendResponse(ctx, err)
}
func (http *httpRules) createRule(ctx context.Context, request requestRulesCreateRule) (response responseRulesCreateRule, err error) {

	response.Status, err = http.svc.CreateRule(ctx, request.UserId, request.Request)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
	}
	return
}
func (http *httpRules) serveCreateRule(ctx *fiber.Ctx) (err error) {

	var request requestRulesCreateRule
	if err = ctx.BodyParser(&request); err != nil {
		ctx.Response().SetStatusCode(fiber.StatusBadRequest)
		_, err = ctx.WriteString("request body could not be decoded: " + err.Error())
		return
	}

	if _userId := string(ctx.Request().Header.Peek("X-User-Id")); _userId != "" {
		var userId int64
		userId, err = strconv.ParseInt(_userId, 10, 64)
		if err != nil {
			ctx.Status(fiber.StatusBadRequest)
			return sendResponse(ctx, "http header could not be decoded: "+err.Error())
		}
		request.UserId = userId
	}

	var response responseRulesCreateRule
	if response, err = http.createRule(ctx.UserContext(), request); err == nil {
		var iResponse interface{} = response
		if redirect, ok := iResponse.(withRedirect); ok {
			return ctx.Redirect(redirect.RedirectTo())
		}

		return sendResponse(ctx, response)
	}
	if errCoder, ok := err.(withErrorCode); ok {
		ctx.Status(errCoder.Code())
	} else {
		ctx.Status(fiber.StatusInternalServerError)
	}
	return sendResponse(ctx, err)
}
func (http *httpRules) updateRuleById(ctx context.Context, request requestRulesUpdateRuleById) (response responseRulesUpdateRuleById, err error) {

	response.Status, err = http.svc.UpdateRuleById(ctx, request.UserId, request.Request)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
	}
	return
}
func (http *httpRules) serveUpdateRuleById(ctx *fiber.Ctx) (err error) {

	var request requestRulesUpdateRuleById
	if err = ctx.BodyParser(&request); err != nil {
		ctx.Response().SetStatusCode(fiber.StatusBadRequest)
		_, err = ctx.WriteString("request body could not be decoded: " + err.Error())
		return
	}

	if _userId := string(ctx.Request().Header.Peek("X-User-Id")); _userId != "" {
		var userId int64
		userId, err = strconv.ParseInt(_userId, 10, 64)
		if err != nil {
			ctx.Status(fiber.StatusBadRequest)
			return sendResponse(ctx, "http header could not be decoded: "+err.Error())
		}
		request.UserId = userId
	}

	var response responseRulesUpdateRuleById
	if response, err = http.updateRuleById(ctx.UserContext(), request); err == nil {
		var iResponse interface{} = response
		if redirect, ok := iResponse.(withRedirect); ok {
			return ctx.Redirect(redirect.RedirectTo())
		}

		return sendResponse(ctx, response)
	}
	if errCoder, ok := err.(withErrorCode); ok {
		ctx.Status(errCoder.Code())
	} else {
		ctx.Status(fiber.StatusInternalServerError)
	}
	return sendResponse(ctx, err)
}
