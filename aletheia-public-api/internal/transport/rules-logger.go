// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"aletheia-public-api/interfaces"
	v1 "aletheia-public-api/interfaces/types/v1"
	"aletheia-public-api/internal/transport/viewer"
	"context"
	"time"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

type loggerRules struct {
	next interfaces.Rules
}

func loggerMiddlewareRules() MiddlewareRules {
	return func(next interfaces.Rules) interfaces.Rules {
		return &loggerRules{next: next}
	}
}

func (m loggerRules) GetRules(ctx context.Context, userId int64) (items v1.RulesResponse, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Rules").Str("method", "getRules").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method":   "rules.getRules",
				"request":  viewer.Sprintf("%+v", requestRulesGetRules{UserId: userId}),
				"response": viewer.Sprintf("%+v", responseRulesGetRules{Items: items}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getRules")
			return
		}
		logger.Info().Func(logHandle).Msg("call getRules")
	}(time.Now())
	return m.next.GetRules(ctx, userId)
}

func (m loggerRules) GetRuleByID(ctx context.Context, userId int64, ruleId string, ruleType string) (rule *v1.RuleDetailResponse, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Rules").Str("method", "getRuleByID").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "rules.getRuleByID",
				"request": viewer.Sprintf("%+v", requestRulesGetRuleByID{
					RuleId:   ruleId,
					RuleType: ruleType,
					UserId:   userId,
				}),
				"response": viewer.Sprintf("%+v", responseRulesGetRuleByID{Rule: rule}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getRuleByID")
			return
		}
		logger.Info().Func(logHandle).Msg("call getRuleByID")
	}(time.Now())
	return m.next.GetRuleByID(ctx, userId, ruleId, ruleType)
}

func (m loggerRules) GetAvailableRules(ctx context.Context, userId int64) (items v1.RulesResponse, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Rules").Str("method", "getAvailableRules").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method":   "rules.getAvailableRules",
				"request":  viewer.Sprintf("%+v", requestRulesGetAvailableRules{UserId: userId}),
				"response": viewer.Sprintf("%+v", responseRulesGetAvailableRules{Items: items}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getAvailableRules")
			return
		}
		logger.Info().Func(logHandle).Msg("call getAvailableRules")
	}(time.Now())
	return m.next.GetAvailableRules(ctx, userId)
}

func (m loggerRules) DeleteRuleByID(ctx context.Context, userId int64, req v1.DeleteRuleRequest) (status bool, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Rules").Str("method", "deleteRuleByID").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "rules.deleteRuleByID",
				"request": viewer.Sprintf("%+v", requestRulesDeleteRuleByID{
					Req:    req,
					UserId: userId,
				}),
				"response": viewer.Sprintf("%+v", responseRulesDeleteRuleByID{Status: status}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call deleteRuleByID")
			return
		}
		logger.Info().Func(logHandle).Msg("call deleteRuleByID")
	}(time.Now())
	return m.next.DeleteRuleByID(ctx, userId, req)
}

func (m loggerRules) CreateRule(ctx context.Context, userId int64, request v1.CreateRuleRequest) (status bool, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Rules").Str("method", "createRule").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "rules.createRule",
				"request": viewer.Sprintf("%+v", requestRulesCreateRule{
					Request: request,
					UserId:  userId,
				}),
				"response": viewer.Sprintf("%+v", responseRulesCreateRule{Status: status}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call createRule")
			return
		}
		logger.Info().Func(logHandle).Msg("call createRule")
	}(time.Now())
	return m.next.CreateRule(ctx, userId, request)
}

func (m loggerRules) UpdateRuleById(ctx context.Context, userId int64, request v1.UpdateRuleRequest) (status bool, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Rules").Str("method", "updateRuleById").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "rules.updateRuleById",
				"request": viewer.Sprintf("%+v", requestRulesUpdateRuleById{
					Request: request,
					UserId:  userId,
				}),
				"response": viewer.Sprintf("%+v", responseRulesUpdateRuleById{Status: status}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call updateRuleById")
			return
		}
		logger.Info().Func(logHandle).Msg("call updateRuleById")
	}(time.Now())
	return m.next.UpdateRuleById(ctx, userId, request)
}
