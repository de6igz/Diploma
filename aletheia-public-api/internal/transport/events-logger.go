// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"aletheia-public-api/interfaces"
	v1 "aletheia-public-api/interfaces/types/v1"
	"aletheia-public-api/internal/transport/viewer"
	"context"
	"time"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

type loggerEvents struct {
	next interfaces.Events
}

func loggerMiddlewareEvents() MiddlewareEvents {
	return func(next interfaces.Events) interfaces.Events {
		return &loggerEvents{next: next}
	}
}

func (m loggerEvents) GetEvents(ctx context.Context, pastHours int, userId int64) (items v1.EventsResponse, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Events").Str("method", "getEvents").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "events.getEvents",
				"request": viewer.Sprintf("%+v", requestEventsGetEvents{
					PastHours: pastHours,
					UserId:    userId,
				}),
				"response": viewer.Sprintf("%+v", responseEventsGetEvents{Items: items}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getEvents")
			return
		}
		logger.Info().Func(logHandle).Msg("call getEvents")
	}(time.Now())
	return m.next.GetEvents(ctx, pastHours, userId)
}

func (m loggerEvents) GetEventByID(ctx context.Context, eventId string, userId int64) (resp v1.EventDetailResponse, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Events").Str("method", "getEventByID").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "events.getEventByID",
				"request": viewer.Sprintf("%+v", requestEventsGetEventByID{
					EventId: eventId,
					UserId:  userId,
				}),
				"response": viewer.Sprintf("%+v", responseEventsGetEventByID{Resp: resp}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getEventByID")
			return
		}
		logger.Info().Func(logHandle).Msg("call getEventByID")
	}(time.Now())
	return m.next.GetEventByID(ctx, eventId, userId)
}

func (m loggerEvents) GetMostRecentEvent(ctx context.Context, userId int64, eventType string) (resp v1.EventDetailResponse, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Events").Str("method", "getMostRecentEvent").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "events.getMostRecentEvent",
				"request": viewer.Sprintf("%+v", requestEventsGetMostRecentEvent{
					EventType: eventType,
					UserId:    userId,
				}),
				"response": viewer.Sprintf("%+v", responseEventsGetMostRecentEvent{Resp: resp}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getMostRecentEvent")
			return
		}
		logger.Info().Func(logHandle).Msg("call getMostRecentEvent")
	}(time.Now())
	return m.next.GetMostRecentEvent(ctx, userId, eventType)
}

func (m loggerEvents) GetEventsByType(ctx context.Context, eventType string, userId int64) (resp v1.EventsByEventTypeResponse, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Events").Str("method", "getEventsByType").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "events.getEventsByType",
				"request": viewer.Sprintf("%+v", requestEventsGetEventsByType{
					EventType: eventType,
					UserId:    userId,
				}),
				"response": viewer.Sprintf("%+v", responseEventsGetEventsByType{Resp: resp}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getEventsByType")
			return
		}
		logger.Info().Func(logHandle).Msg("call getEventsByType")
	}(time.Now())
	return m.next.GetEventsByType(ctx, eventType, userId)
}
