// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"aletheia-public-api/interfaces"
	v1 "aletheia-public-api/interfaces/types/v1"
	"aletheia-public-api/internal/transport/viewer"
	"context"
	"time"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

type loggerProjects struct {
	next interfaces.Projects
}

func loggerMiddlewareProjects() MiddlewareProjects {
	return func(next interfaces.Projects) interfaces.Projects {
		return &loggerProjects{next: next}
	}
}

func (m loggerProjects) GetProjects(ctx context.Context, userId int64) (items v1.ProjectsResponse, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Projects").Str("method", "getProjects").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method":   "projects.getProjects",
				"request":  viewer.Sprintf("%+v", requestProjectsGetProjects{UserId: userId}),
				"response": viewer.Sprintf("%+v", responseProjectsGetProjects{Items: items}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getProjects")
			return
		}
		logger.Info().Func(logHandle).Msg("call getProjects")
	}(time.Now())
	return m.next.GetProjects(ctx, userId)
}

func (m loggerProjects) GetProjectByID(ctx context.Context, projectID string, userId int64) (project v1.ProjectDetailResponse, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Projects").Str("method", "getProjectByID").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "projects.getProjectByID",
				"request": viewer.Sprintf("%+v", requestProjectsGetProjectByID{
					ProjectID: projectID,
					UserId:    userId,
				}),
				"response": viewer.Sprintf("%+v", responseProjectsGetProjectByID{Project: project}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getProjectByID")
			return
		}
		logger.Info().Func(logHandle).Msg("call getProjectByID")
	}(time.Now())
	return m.next.GetProjectByID(ctx, projectID, userId)
}

func (m loggerProjects) DeleteProjectByID(ctx context.Context, projectID string, userId int64) (status bool, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Projects").Str("method", "deleteProjectByID").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "projects.deleteProjectByID",
				"request": viewer.Sprintf("%+v", requestProjectsDeleteProjectByID{
					ProjectID: projectID,
					UserId:    userId,
				}),
				"response": viewer.Sprintf("%+v", responseProjectsDeleteProjectByID{Status: status}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call deleteProjectByID")
			return
		}
		logger.Info().Func(logHandle).Msg("call deleteProjectByID")
	}(time.Now())
	return m.next.DeleteProjectByID(ctx, projectID, userId)
}

func (m loggerProjects) CreateProject(ctx context.Context, project *v1.CreateProjectRequest, userId int64) (status bool, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Projects").Str("method", "createProject").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "projects.createProject",
				"request": viewer.Sprintf("%+v", requestProjectsCreateProject{
					Project: project,
					UserId:  userId,
				}),
				"response": viewer.Sprintf("%+v", responseProjectsCreateProject{Status: status}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call createProject")
			return
		}
		logger.Info().Func(logHandle).Msg("call createProject")
	}(time.Now())
	return m.next.CreateProject(ctx, project, userId)
}

func (m loggerProjects) UpdateProject(ctx context.Context, project *v1.UpdateProjectRequest, projectID string, userId int64) (status bool, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Projects").Str("method", "updateProject").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "projects.updateProject",
				"request": viewer.Sprintf("%+v", requestProjectsUpdateProject{
					Project:   project,
					ProjectID: projectID,
					UserId:    userId,
				}),
				"response": viewer.Sprintf("%+v", responseProjectsUpdateProject{Status: status}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call updateProject")
			return
		}
		logger.Info().Func(logHandle).Msg("call updateProject")
	}(time.Now())
	return m.next.UpdateProject(ctx, project, projectID, userId)
}
